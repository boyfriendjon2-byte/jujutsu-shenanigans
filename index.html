<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Jujutsu Shenanigans – V9 (GitHub Ready)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; user-select: none; font-family: 'Arial', sans-serif; }
    
    #ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
    }

    #status-box {
      background: rgba(0,0,0,0.8); color: white; padding: 10px;
      margin: 10px; border-radius: 5px; border-left: 5px solid yellow;
      pointer-events: auto;
    }

    #controls-hint {
      text-align: center; color: #fff; padding: 15px; font-size: 14px;
      text-shadow: 2px 2px 0 #000; font-weight: bold; 
      background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
    }

    #dead-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(139, 0, 0, 0.6); display: none;
      align-items: center; justify-content: center;
      color: white; font-size: 50px; font-weight: 900;
      z-index: 999; text-transform: uppercase;
      text-shadow: 0 0 20px black;
    }
  </style>
</head>
<body>

  <div id="dead-screen">Has Muerto</div>

  <div id="ui-layer">
    <div id="status-box">ESTADO: <span id="status-text" style="color:yellow">Conectando...</span></div>
    <div id="controls-hint">WASD: Mover | CLICK: M1 Combo | ESPACIO: Dash | E: Dominio</div>
  </div>

  <audio id="domainAudio" src="dominio.mp3"></audio>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.joinplayroom.com/playroomkit/multiplayer.full.umd.js"></script>

  <script>
    const { insertCoin, onPlayerJoin, myPlayer, getState, setState } = Playroom;

    // --- CONFIGURACIÓN ---
    const CONFIG = {
      MAX_HP: 100,
      DASH_CD: 1000,
      PUNCH_CD: 400,
      COMBO_RESET: 1500,
      DOMAIN_TIME: 29000,
      DOMAIN_RADIUS: 20
    };

    // Variables Globales
    let scene, camera, renderer;
    const avatars = {}; 
    let isOffline = false; // Bandera crítica para evitar errores

    // Estado Local
    const controls = { fwd: false, back: false, left: false, right: false };
    let lastDash = 0;
    let lastPunch = 0;
    let comboCount = 0;
    let lastComboTime = 0;
    let isPunching = false;
    let isRagdolled = false;
    let isFrozen = false;
    
    // Referencias Dominio
    let activeDomain = null;
    let domainSphere = null;
    let domainFloor = null;

    // ==========================================
    // 1. INICIALIZACIÓN HÍBRIDA
    // ==========================================
    async function init() {
      const statusText = document.getElementById('status-text');
      const statusBox = document.getElementById('status-box');

      try {
        // Intentamos conectar. Si tarda más de 2s o da error CORS, pasamos a Offline.
        const connPromise = insertCoin({ skipLobby: true });
        const timeoutPromise = new Promise((_, r) => setTimeout(() => r("TIMEOUT"), 2000));
        
        await Promise.race([connPromise, timeoutPromise]);
        
        statusText.innerText = "ONLINE (Multijugador)";
        statusText.style.color = "#00ff00";
        statusBox.style.borderLeft = "5px solid #00ff00";

      } catch (err) {
        console.warn("Modo Offline activado:", err);
        isOffline = true;
        statusText.innerText = "OFFLINE (Entrenamiento vs Dummy)";
        statusText.style.color = "#ffaa00";
        statusBox.style.borderLeft = "5px solid #ffaa00";
        
        // Crear Bot de Entrenamiento
        spawnDummy();
      }

      setupScene();
      
      // Manejar jugadores que entran
      onPlayerJoin((state) => {
        spawnAvatar(state);
      });

      animate();
    }

    // ==========================================
    // 2. SISTEMA DE JUGADORES
    // ==========================================
    function spawnAvatar(state) {
      const id = state.id;
      // Protección contra crash de colores
      let hex = 0xffffff;
      try { 
          const profile = state.getProfile();
          if(profile && profile.color) hex = profile.color.hex; 
      } catch(e) {}

      const mesh = createCharacterMesh(hex);
      scene.add(mesh);

      avatars[id] = { 
        mesh: mesh, 
        state: state, 
        localHp: CONFIG.MAX_HP // Vida simulada para offline
      };

      state.onQuit(() => {
        scene.remove(mesh);
        delete avatars[id];
      });
    }

    function spawnDummy() {
      // Simular un jugador remoto para el modo offline
      const dummyState = {
        id: "dummy_bot",
        getProfile: () => ({ color: { hex: 0xff0000 } }),
        // Estado interno falso
        _data: { pos: {x:5, y:0, z:0}, hp: 100, ragdollState: false },
        getState: function(k) { return this._data[k]; },
        setState: function(k, v) { this._data[k] = v; },
        onQuit: () => {}
      };
      
      // Retraso pequeño para simular carga
      setTimeout(() => spawnAvatar(dummyState), 500);
    }

    // ==========================================
    // 3. GRÁFICOS
    // ==========================================
    function setupScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 20, 120);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 10, 15);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(20, 50, 20);
      light.castShadow = true;
      scene.add(light);

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0x228B22 }));
      floor.rotation.x = -Math.PI/2;
      floor.receiveShadow = true;
      scene.add(floor);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      window.addEventListener('keydown', e => handleKey(e.code, true));
      window.addEventListener('keyup', e => handleKey(e.code, false));
      window.addEventListener('mousedown', e => { if(e.button===0) doPunch(); });
    }

    function createCharacterMesh(color) {
      const group = new THREE.Group();
      const matSuit = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
      const matSkin = new THREE.MeshStandardMaterial({ color: 0xffccaa });

      // Torso
      const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.5), matSuit);
      torso.position.y = 1.6; torso.castShadow = true; group.add(torso);
      
      // Efecto de Daño (Flash rojo invisible)
      const flash = new THREE.Mesh(new THREE.BoxGeometry(1.1, 1.3, 0.6), new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0}));
      flash.position.y = 1.6; flash.name = "DamageFlash"; group.add(flash);

      // Cabeza
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), matSkin);
      head.position.y = 2.5; head.castShadow = true; group.add(head);

      // Brazos
      const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.1, 0.35), matSuit);
      rArm.position.set(0.75, 1.6, 0); rArm.name = "RightArm"; rArm.castShadow = true; group.add(rArm);
      const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.1, 0.35), matSuit);
      lArm.position.set(-0.75, 1.6, 0); lArm.castShadow = true; group.add(lArm);

      // Piernas
      const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.1, 0.4), matSuit);
      rLeg.position.set(0.25, 0.55, 0); rLeg.castShadow = true; group.add(rLeg);
      const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.1, 0.4), matSuit);
      lLeg.position.set(-0.25, 0.55, 0); lLeg.castShadow = true; group.add(lLeg);

      // Barra de Vida
      const bg = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.2), new THREE.MeshBasicMaterial({color:0x550000}));
      bg.position.set(0, 3.5, 0); bg.name="BarBG"; group.add(bg);
      const fg = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.2), new THREE.MeshBasicMaterial({color:0x00ff00}));
      fg.position.set(0, 3.5, 0.01); fg.name="BarFG"; group.add(fg);

      return group;
    }

    // ==========================================
    // 4. LÓGICA DE JUEGO (M1 & DOMINIO)
    // ==========================================
    function handleKey(k, d) {
      if(k==='KeyW') controls.fwd = d;
      if(k==='KeyS') controls.back = d;
      if(k==='KeyA') controls.left = d;
      if(k==='KeyD') controls.right = d;
      if(d && k==='Space') doDash();
      if(d && k==='KeyE') doDomain();
    }

    function doDash() {
      if(Date.now() - lastDash < CONFIG.DASH_CD || isFrozen) return;
      lastDash = Date.now();
      
      const me = myPlayer();
      if(!me && !isOffline) return; // Si no hay jugador y no es offline, salir.
      
      // En modo offline, 'myPlayer()' puede devolver null, así que usamos el 'avatars' local si es necesario o simulamos
      // Pero Playroom suele devolver un objeto local simulado si falla. Si no, usaremos lógica defensiva.
      
      let pos = {x:0, y:0, z:0};
      if (me) pos = me.getState('pos') || pos;

      const dir = new THREE.Vector3();
      if(controls.fwd) dir.z -= 1;
      if(controls.back) dir.z += 1;
      if(controls.left) dir.x -= 1;
      if(controls.right) dir.x += 1;
      if(dir.length()===0) dir.z -= 1;
      dir.normalize();

      const dest = { x: pos.x + dir.x * 6, z: pos.z + dir.z * 6 };
      const final = checkBarrier(dest.x, dest.z);
      
      if(me) me.setState('pos', {x: final.x, y:0, z: final.z}, false);
    }

    function doPunch() {
      if(Date.now() - lastPunch < CONFIG.PUNCH_CD || isFrozen || isPunching) return;
      const now = Date.now();
      
      // Combo Reset
      if(now - lastComboTime > CONFIG.COMBO_RESET) comboCount = 0;
      comboCount++;
      if(comboCount > 4) comboCount = 1;

      lastPunch = now;
      lastComboTime = now;
      isPunching = true;

      const me = myPlayer();
      if(!me && !isOffline) return;

      // Animación
      if(me) animateArm(me.id);

      // Calcular Daño
      let damage = (comboCount === 4) ? 10 : 5; // 4to golpe duele más
      let doRagdoll = (comboCount === 4); // 4to golpe tira al suelo

      // Hitbox
      let myPos = {x:0, y:0, z:0};
      if(me) myPos = me.getState('pos') || myPos;

      for(const id in avatars) {
        if(me && id === me.id) continue; // No pegarse a uno mismo
        
        const enemy = avatars[id];
        const ePos = enemy.state.getState('pos') || {x:0, y:0, z:0};
        const dist = Math.hypot(myPos.x - ePos.x, myPos.z - ePos.z);

        if(dist < 3.5) {
            // ¡IMPACTO!
            triggerDamageEffect(id);

            if(isOffline) {
                // Modo Local: Restar vida directamente
                enemy.localHp -= damage;
                if(enemy.localHp <= 0) {
                    enemy.localHp = CONFIG.MAX_HP;
                    enemy.state.setState('pos', {x:(Math.random()-0.5)*10, y:0, z:(Math.random()-0.5)*10});
                }
                enemy.state.setState('hp', enemy.localHp);
                
                if(doRagdoll) {
                    enemy.state.setState('ragdollState', true);
                    setTimeout(() => enemy.state.setState('ragdollState', false), 2000);
                }
            } else {
                // Modo Online: Enviar evento
                me.setState('attack', { target: id, dmg: damage, ragdoll: doRagdoll, id: Math.random() }, true);
            }
        }
      }

      setTimeout(() => isPunching = false, 200);
    }

    function animateArm(id) {
        if(!avatars[id]) return;
        const arm = avatars[id].mesh.getObjectByName("RightArm");
        if(arm) {
            arm.rotation.x = -Math.PI/2;
            setTimeout(() => arm.rotation.x = 0, 150);
        }
    }

    function triggerDamageEffect(id) {
        if(!avatars[id]) return;
        const flash = avatars[id].mesh.getObjectByName("DamageFlash");
        if(flash) {
            flash.material.opacity = 0.8;
            setTimeout(() => flash.material.opacity = 0, 150);
        }
        // Temblor
        avatars[id].mesh.position.x += (Math.random()-0.5)*0.5;
        setTimeout(() => avatars[id].mesh.position.x = avatars[id].state.getState('pos').x, 50);
    }

    // --- RECIBIR DAÑO ONLINE ---
    function checkIncomingDamage() {
        if(isOffline) return; 
        const me = myPlayer();
        if(!me) return;

        for(const id in avatars) {
            if(id === me.id) continue;
            const enemy = avatars[id];
            const atk = enemy.state.getState('attack');
            
            // Si hay un ataque nuevo dirigido a mí
            if(atk && atk.target === me.id && avatars[me.id].lastDmgId !== atk.id) {
                avatars[me.id].lastDmgId = atk.id;
                triggerDamageEffect(me.id);
                
                let hp = me.getState('hp');
                if(hp === undefined) hp = CONFIG.MAX_HP;
                hp -= atk.dmg;

                if(atk.ragdoll) {
                    isRagdolled = true;
                    me.setState('ragdollState', true, true);
                    setTimeout(() => { 
                        isRagdolled = false; 
                        me.setState('ragdollState', false, true); 
                    }, 2000);
                }

                if(hp <= 0) {
                    hp = CONFIG.MAX_HP;
                    respawn();
                }
                me.setState('hp', hp, true);
            }
        }
    }

    function respawn() {
        const me = myPlayer();
        me.setState('pos', {x:0, y:0, z:0}, true);
        const el = document.getElementById('dead-screen');
        el.style.display = 'flex';
        setTimeout(() => el.style.display = 'none', 1500);
    }

    // ==========================================
    // 5. DOMINIO (EXPANSIÓN)
    // ==========================================
    function doDomain() {
        // Verificar si ya hay uno activo
        let isAnyActive = false;
        if(isOffline) {
            if(activeDomain) isAnyActive = true;
        } else {
            const d = getState('domain');
            if(d && d.active) isAnyActive = true;
        }

        if(isAnyActive) return;

        const me = myPlayer();
        if(!me && !isOffline) return;
        
        // Posición actual
        let pos = {x:0, y:0, z:0};
        if(me) pos = me.getState('pos') || pos;

        const domainData = { active: true, owner: (me ? me.id : 'local'), pos: pos, id: Math.random() };

        if(isOffline) {
            // Activar localmente
            applyDomainState(domainData);
            setTimeout(() => applyDomainState({active:false}), CONFIG.DOMAIN_TIME);
        } else {
            // Activar en red
            setState('domain', domainData, true);
            setTimeout(() => {
                const d = getState('domain');
                if(d && d.active && d.owner === me.id) setState('domain', {active:false}, true);
            }, CONFIG.DOMAIN_TIME);
        }
    }

    function updateDomainLoop() {
        if(isOffline) return; // En offline ya lo manejamos directo
        const d = getState('domain');
        applyDomainState(d);
    }

    function applyDomainState(d) {
        // Apagar
        if(activeDomain && (!d || !d.active || d.id !== activeDomain.id)) {
            scene.remove(domainSphere); scene.remove(domainFloor);
            activeDomain = null; isFrozen = false;
            document.getElementById('domainAudio').pause();
        }

        // Encender
        if(d && d.active && !activeDomain) {
            activeDomain = d;
            const me = myPlayer();
            const aud = document.getElementById('domainAudio');
            aud.currentTime = 0; aud.play().catch(()=>{});

            // Visuales
            const sGeo = new THREE.SphereGeometry(CONFIG.DOMAIN_RADIUS, 32, 32);
            const sMat = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.3, side:THREE.BackSide});
            domainSphere = new THREE.Mesh(sGeo, sMat);
            domainSphere.position.set(d.pos.x, 2, d.pos.z);
            scene.add(domainSphere);

            const fGeo = new THREE.CircleGeometry(CONFIG.DOMAIN_RADIUS, 64);
            const fMat = new THREE.MeshBasicMaterial({color:0xffffff, side:THREE.DoubleSide});
            domainFloor = new THREE.Mesh(fGeo, fMat);
            domainFloor.rotation.x = -Math.PI/2;
            domainFloor.position.set(d.pos.x, 0.05, d.pos.z);
            scene.add(domainFloor);

            // Verificar si me congelo
            if(me || isOffline) {
                let myPos = {x:0, y:0, z:0};
                let myId = 'local';
                if(me) { myPos = me.getState('pos') || myPos; myId = me.id; }
                
                const dist = Math.hypot(myPos.x - d.pos.x, myPos.z - d.pos.z);
                if(dist <= CONFIG.DOMAIN_RADIUS && myId !== d.owner) {
                    isFrozen = true;
                }
            }
        }
    }

    function checkBarrier(x, z) {
        if(!activeDomain) return {x,z};
        const dx = x - activeDomain.pos.x;
        const dz = z - activeDomain.pos.z;
        const dist = Math.hypot(dx, dz);
        const R = CONFIG.DOMAIN_RADIUS;
        
        if(dist > R - 0.5) {
            const a = Math.atan2(dz, dx);
            return { x: activeDomain.pos.x + Math.cos(a)*(R-0.5), z: activeDomain.pos.z + Math.sin(a)*(R-0.5) };
        }
        return {x,z};
    }

    // ==========================================
    // 6. BUCLE PRINCIPAL
    // ==========================================
    function animate() {
        requestAnimationFrame(animate);
        
        const me = myPlayer();
        // Si estamos offline, 'me' puede ser null pero seguimos renderizando
        if(!me && !isOffline) return; 

        if(!isOffline) {
            checkIncomingDamage();
            updateDomainLoop();
        }

        // Movimiento Local
        if(!isFrozen && !isRagdolled) {
            let pos = {x:0,y:0,z:0};
            if(me) pos = me.getState('pos') || pos;
            
            const speed = 0.15;
            let dx=0, dz=0;
            if(controls.fwd) dz -= speed;
            if(controls.back) dz += speed;
            if(controls.left) dx -= speed;
            if(controls.right) dx += speed;

            if(dx!==0 || dz!==0) {
                const dest = { x: pos.x + dx, z: pos.z + dz };
                const final = checkBarrier(dest.x, dest.z);
                if(me) me.setState('pos', {x:final.x, y:0, z:final.z}, false);
            }
        }

        // Renderizar Avatares
        for(const id in avatars) {
            const { mesh, state } = avatars[id];
            const p = state.getState('pos') || {x:0,y:0,z:0};
            
            mesh.position.lerp(new THREE.Vector3(p.x, mesh.position.y, p.z), 0.3);

            const lastP = mesh.userData.lp || p;
            const dx = p.x - lastP.x;
            const dz = p.z - lastP.z;
            if(Math.hypot(dx,dz) > 0.01) mesh.rotation.y = Math.atan2(dx, dz);
            mesh.userData.lp = p;

            // Ragdoll Visual
            const isRag = state.getState('ragdollState');
            if(isRag) {
                mesh.rotation.x = -Math.PI/2; 
                mesh.position.y = 0.5;
            } else {
                mesh.rotation.x = 0; 
                mesh.position.y = 0;
            }

            // Barra de Vida
            let hp = state.getState('hp');
            if(hp === undefined) hp = CONFIG.MAX_HP;
            
            const fg = mesh.getObjectByName("BarFG");
            const bg = mesh.getObjectByName("BarBG");
            if(fg && bg) {
                fg.lookAt(camera.position); bg.lookAt(camera.position);
                fg.scale.x = Math.max(0, hp / CONFIG.MAX_HP);
                fg.visible = hp > 0;
            }
        }

        // Cámara
        let cPos = {x:0, y:0, z:0};
        if(me) cPos = me.getState('pos') || cPos;
        
        camera.position.lerp(new THREE.Vector3(cPos.x, 12, cPos.z + 18), 0.1);
        camera.lookAt(cPos.x, 1, cPos.z);

        renderer.render(scene, camera);
    }

    init().catch(console.error);
  </script>
</body>
</html>
