<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Jujutsu Shenanigans ‚Äì V16 (Camera Perfect Fix)</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Anton&display=swap');

    body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Anton', sans-serif; }
    
    #ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
    }

    /* MIRA CENTRAL (Crosshair) */
    #crosshair {
      position: absolute; top: 50%; left: 50%;
      width: 6px; height: 6px;
      background: white;
      border: 2px solid black;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      z-index: 50; display: none;
    }

    /* HUD */
    #hud-bottom {
      display: flex; justify-content: space-between; align-items: flex-end;
      padding: 20px; width: 100%; box-sizing: border-box;
    }

    .health-container { width: 300px; pointer-events: auto; }
    .health-label { color: white; font-size: 20px; text-shadow: 2px 2px 0 #000; margin-bottom: 5px; }
    .health-bar-bg { width: 100%; height: 25px; background: #330000; border: 2px solid #fff; transform: skewX(-20deg); }
    .health-bar-fill { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s; }

    .skills-container { display: flex; gap: 15px; margin-bottom: 10px; margin-right: 40px; }
    .skill-box {
      width: 60px; height: 60px; background: rgba(0,0,0,0.7);
      border: 2px solid #fff; border-radius: 8px;
      display: flex; align-items: center; justify-content: center;
      color: white; font-size: 24px; position: relative;
    }
    .skill-key { position: absolute; top: 2px; left: 4px; font-size: 12px; color: #ffff00; }
    .cooldown-overlay {
      position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
      background: rgba(255, 0, 0, 0.7); transition: height 0.1s linear;
    }

    #dead-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(100, 0, 0, 0.6); display: none;
      align-items: center; justify-content: center;
      color: white; font-size: 80px; text-transform: uppercase;
      z-index: 999;
    }

    .damage-text {
        position: absolute; color: #ff3333; font-weight: 900; font-size: 32px;
        text-shadow: 2px 2px 0 #000; pointer-events: none;
        animation: floatUp 0.8s forwards ease-out;
    }
    @keyframes floatUp {
        0% { transform: translateY(0) scale(1); opacity: 1; }
        100% { transform: translateY(-80px) scale(1.5); opacity: 0; }
    }
    
    #connection-status {
        position: absolute; top: 10px; right: 10px;
        color: white; font-family: monospace; font-size: 12px;
        background: rgba(0,0,0,0.5); padding: 5px;
    }
    
    #lock-msg {
        position: absolute; top: 40%; width: 100%; text-align: center;
        color: yellow; font-weight: bold; font-size: 20px;
        text-shadow: 0 0 5px black; pointer-events: none;
        background: rgba(0,0,0,0.5); padding: 10px;
    }
  </style>
</head>
<body>

  <div id="dead-screen">WASTED</div>
  <div id="damage-container"></div>
  <div id="connection-status">Conectando...</div>
  <div id="lock-msg">HAZ CLIC Y PRESIONA [CTRL] PARA JUGAR</div>
  
  <div id="crosshair"></div>

  <div id="ui-layer">
    <div style="height: 50px;"></div>

    <div id="hud-bottom">
      <div class="health-container">
        <div class="health-label">HP <span id="hp-text">100/100</span></div>
        <div class="health-bar-bg"><div id="my-health-bar" class="health-bar-fill"></div></div>
      </div>

      <div class="skills-container">
        <div class="skill-box"><div class="skill-key">M1</div>üëä<div id="cd-punch" class="cooldown-overlay"></div></div>
        <div class="skill-box"><div class="skill-key">SPACE</div>üí®<div id="cd-dash" class="cooldown-overlay"></div></div>
        <div class="skill-box" style="border-color: #a855f7;"><div class="skill-key">E</div>ü§û<div id="cd-domain" class="cooldown-overlay"></div></div>
      </div>
    </div>
  </div>

  <audio id="domainAudio" src="dominio.mp3"></audio>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.joinplayroom.com/playroomkit/multiplayer.full.umd.js"></script>

  <script>
    const { insertCoin, onPlayerJoin, myPlayer, getState, setState } = Playroom;

    const CONFIG = {
      MAX_HP: 100,
      HIT_DIST: 4.5,
      DMG_NORMAL: 10,
      DMG_FINISHER: 20,
      DASH_CD: 1500,
      PUNCH_CD: 500,
      DOMAIN_TIME: 29000,
      DOMAIN_RADIUS: 22
    };

    // Globales
    let scene, camera, renderer;
    const avatars = {}; 
    let isOffline = false; 

    // C√ÅMARA Y CONTROL
    let cameraAngle = Math.PI; // Empezar mirando la espalda
    let cameraVertical = 0.5;  // Altura media
    let isMouseLocked = false;
    const controls = { fwd: false, back: false, left: false, right: false };

    // Estado Local
    let lastDash = 0;
    let lastPunch = 0;
    let comboCount = 0;
    let lastComboTime = 0;
    let isPunching = false;
    let isFrozen = false;
    let isRagdolled = false;

    // Dominio
    let activeDomain = null;
    let domainGroup = null;

    // ==========================================
    // 1. INICIO
    // ==========================================
    async function init() {
      const statusLabel = document.getElementById('connection-status');

      if (window.location.protocol === 'file:') {
        activateOffline("OFFLINE (Modo Local)");
      } else {
        try {
          const connPromise = insertCoin({ skipLobby: true });
          const timeoutPromise = new Promise((_, r) => setTimeout(() => r("TIMEOUT"), 2000));
          await Promise.race([connPromise, timeoutPromise]);
          statusLabel.innerText = "ONLINE ‚úÖ";
          statusLabel.style.color = "#00ff00";
        } catch (err) {
          activateOffline("OFFLINE (Fallo Red) ‚ö†Ô∏è");
        }
      }

      setupScene();
      
      if (!isOffline) {
        onPlayerJoin(spawnAvatar);
      } else {
        spawnLocalPlayer();
        spawnDummyBot();
      }

      animate();
    }

    function activateOffline(msg) {
        isOffline = true;
        const sl = document.getElementById('connection-status');
        sl.innerText = msg;
        sl.style.color = "yellow";
    }

    // ==========================================
    // 2. SISTEMA DE AVATARES
    // ==========================================
    function spawnAvatar(state) {
      const id = state.id;
      let hex = 0xffffff;
      try { const p = state.getProfile(); if(p && p.color) hex = p.color.hex; } catch(e) {}
      
      const mesh = createMesh(hex);
      scene.add(mesh);

      if (!isOffline && myPlayer().id === id) {
          state.setState('hp', CONFIG.MAX_HP, true);
      }

      avatars[id] = { 
          mesh: mesh, 
          state: state, 
          lastDmgId: null,
          walkTime: 0
      };

      state.onQuit(() => {
        scene.remove(mesh);
        delete avatars[id];
      });
    }

    function spawnLocalPlayer() {
        const myId = "local_player";
        const mockState = createMockState(myId, 0x0000ff);
        spawnAvatar(mockState);
    }

    function spawnDummyBot() {
        const botId = "dummy_bot";
        const mockState = createMockState(botId, 0xff0000);
        mockState._data.pos = {x: 5, y:0, z:0};
        spawnAvatar(mockState);
    }

    function createMockState(id, color) {
        return {
            id: id,
            getProfile: () => ({ color: { hex: color } }),
            _data: { pos: {x:0,y:0,z:0}, hp: 100, ragdoll: false },
            getState: function(k) { return this._data[k]; },
            setState: function(k, v) { this._data[k] = v; },
            onQuit: () => {}
        };
    }

    // ==========================================
    // 3. C√ÅMARA FIX & CONTROLES
    // ==========================================
    
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Control') {
            if (!isMouseLocked) document.body.requestPointerLock();
            else document.exitPointerLock();
        }
        handleKey(e.code, true);
    });

    document.addEventListener('keyup', (e) => handleKey(e.code, false));
    document.addEventListener('mousedown', (e) => { if(e.button===0) doPunch(); });

    document.addEventListener('pointerlockchange', () => {
        isMouseLocked = (document.pointerLockElement === document.body);
        const cross = document.getElementById('crosshair');
        const msg = document.getElementById('lock-msg');
        
        if (isMouseLocked) {
            cross.style.display = 'block';
            msg.style.display = 'none';
        } else {
            cross.style.display = 'none';
            msg.style.display = 'block';
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (isMouseLocked) {
            // FIX: Invertir X para rotaci√≥n natural (mouse derecha = camara derecha)
            cameraAngle -= e.movementX * 0.002; 
            
            // FIX: Invertir Y para comportamiento normal (mouse abajo = mirar abajo/camara sube)
            cameraVertical += e.movementY * 0.002; 
            
            // Limitar para no dar la vuelta completa por arriba o abajo
            cameraVertical = Math.max(-0.5, Math.min(2.0, cameraVertical));
        }
    });

    function handleKey(k, d) {
        if(k==='KeyW') controls.fwd = d;
        if(k==='KeyS') controls.back = d;
        if(k==='KeyA') controls.left = d;
        if(k==='KeyD') controls.right = d;
        if(d && k==='Space') doDash();
        if(d && k==='KeyE') doDomain();
    }

    // ==========================================
    // 4. COMBATE
    // ==========================================
    function doPunch() {
        const now = Date.now();
        if(now - lastPunch < CONFIG.PUNCH_CD || isFrozen || isPunching || isRagdolled) return;
        
        if(now - lastComboTime > 1500) comboCount = 0;
        comboCount++;
        if(comboCount > 4) comboCount = 1;
        
        lastPunch = now;
        lastComboTime = now;
        isPunching = true;
        triggerCooldownUI('cd-punch', CONFIG.PUNCH_CD);

        const me = getMe();
        if(!me) return;

        animateAttack(me.id);

        const damage = (comboCount === 4) ? CONFIG.DMG_FINISHER : CONFIG.DMG_NORMAL;
        const doRagdoll = (comboCount === 4);
        const myPos = getPos(me);
        
        for(const id in avatars) {
            if(id === me.id) continue;

            const target = avatars[id];
            const tPos = getPos(target.state);
            const dist = Math.hypot(myPos.x - tPos.x, myPos.z - tPos.z);

            if(dist < CONFIG.HIT_DIST) {
                triggerHitEffect(id);
                showDamageNumber(tPos, damage, doRagdoll);

                if(isOffline) {
                    let currentHp = target.state.getState('hp');
                    currentHp -= damage;
                    if(currentHp <= 0) {
                        currentHp = CONFIG.MAX_HP;
                        target.state.setState('pos', {x:(Math.random()-0.5)*10, y:0, z:(Math.random()-0.5)*10});
                    }
                    target.state.setState('hp', currentHp);
                    if(doRagdoll) {
                        target.state.setState('ragdoll', true);
                        setTimeout(() => target.state.setState('ragdoll', false), 2500);
                    }
                } else {
                    me.setState('attackData', {
                        targetId: id,
                        dmg: damage,
                        ragdoll: doRagdoll,
                        hitId: Math.random()
                    }, true);
                }
            }
        }
        setTimeout(() => isPunching = false, 250);
    }

    function checkIncomingDamage() {
        if(isOffline) return;
        const me = getMe();
        if(!me) return;

        for(const id in avatars) {
            if(id === me.id) continue;
            const attacker = avatars[id];
            const attack = attacker.state.getState('attackData');

            if(attack && attack.targetId === me.id && avatars[me.id].lastDmgId !== attack.hitId) {
                avatars[me.id].lastDmgId = attack.hitId; 

                triggerHitEffect(me.id);
                showDamageNumber(getPos(me), attack.dmg, attack.ragdoll);

                let myHp = me.getState('hp');
                if(myHp === undefined) myHp = CONFIG.MAX_HP;
                myHp -= attack.dmg;

                if(attack.ragdoll) {
                    isRagdolled = true;
                    me.setState('ragdoll', true, true);
                    setTimeout(() => { isRagdolled = false; me.setState('ragdoll', false, true); }, 2500);
                }

                if(myHp <= 0) {
                    myHp = CONFIG.MAX_HP;
                    respawn();
                }
                me.setState('hp', myHp, true);
                updateHealthUI(myHp);
            }
        }
    }

    // ==========================================
    // 5. ANIMACIONES
    // ==========================================
    function animateAttack(id) {
        if(!avatars[id]) return;
        const mesh = avatars[id].mesh;
        const torso = mesh.getObjectByName("Torso");
        const arm = mesh.getObjectByName("RightArm");
        
        if(arm && torso) {
            arm.rotation.x = -Math.PI / 1.8;
            torso.rotation.x = 0.3;
            setTimeout(() => {
                arm.rotation.x = 0;
                torso.rotation.x = 0;
            }, 200);
        }
    }

    function animateWalk(id, isMoving, time) {
        if(!avatars[id]) return;
        const mesh = avatars[id].mesh;
        
        if(isMoving) {
            mesh.position.y = Math.sin(time * 15) * 0.1; 
            const rArm = mesh.getObjectByName("RightArm");
            const lArm = mesh.getObjectByName("LeftArm");
            if(rArm) rArm.rotation.x = Math.sin(time * 15) * 0.5;
            if(lArm) lArm.rotation.x = Math.sin(time * 15 + Math.PI) * 0.5;
        } else {
            mesh.position.y = 0;
            const rArm = mesh.getObjectByName("RightArm");
            const lArm = mesh.getObjectByName("LeftArm");
            if(rArm) rArm.rotation.x = 0;
            if(lArm) lArm.rotation.x = 0;
        }
    }

    function showDamageNumber(pos, dmg, isCrit) {
        const vector = new THREE.Vector3(pos.x, 3, pos.z);
        vector.project(camera);
        
        const x = (vector.x * .5 + .5) * window.innerWidth;
        const y = (-(vector.y * .5) + .5) * window.innerHeight;

        const el = document.createElement('div');
        el.className = 'damage-text';
        el.innerText = `-${dmg}`;
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
        if(isCrit) {
            el.style.color = "#ff00ff"; el.innerText += "!";
        }
        document.getElementById('damage-container').appendChild(el);
        setTimeout(() => el.remove(), 800);
    }

    function createCosmicDomain(pos) {
        const group = new THREE.Group();
        group.position.set(pos.x, 2, pos.z);

        const geo = new THREE.SphereGeometry(CONFIG.DOMAIN_RADIUS, 32, 32);
        const mat = new THREE.MeshBasicMaterial({ color: 0x1a0033, side: THREE.BackSide, transparent: true, opacity: 0.95 });
        const sphere = new THREE.Mesh(geo, mat);
        group.add(sphere);

        const starGeo = new THREE.BufferGeometry();
        const starCount = 800;
        const posArray = new Float32Array(starCount * 3);
        for(let i=0; i<starCount * 3; i++) posArray[i] = (Math.random() - 0.5) * CONFIG.DOMAIN_RADIUS * 1.8;
        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true });
        const starField = new THREE.Points(starGeo, starMat);
        group.add(starField);

        const floor = new THREE.Mesh(new THREE.CircleGeometry(CONFIG.DOMAIN_RADIUS - 0.5, 32), new THREE.MeshBasicMaterial({color: 0x000000, transparent: true, opacity: 0.5, side: THREE.DoubleSide}));
        floor.rotation.x = Math.PI / 2;
        floor.position.y = -1.9;
        group.add(floor);

        return group;
    }

    function doDomain() {
        if(isFrozen) return;
        const me = getMe();
        if(!me) return;

        const ui = document.getElementById('cd-domain');
        if(ui.style.height && ui.style.height !== '0%') return;
        triggerCooldownUI('cd-domain', CONFIG.DOMAIN_TIME);

        const pos = getPos(me);
        const data = { active: true, owner: me.id, pos: pos, id: Math.random() };

        if(isOffline) {
            activeDomain = data;
            updateDomainVisuals(data);
            setTimeout(() => { activeDomain=null; updateDomainVisuals(null); }, CONFIG.DOMAIN_TIME);
        } else {
            setState('domain', data, true);
            setTimeout(() => {
                const d = getState('domain');
                if(d && d.owner===me.id) setState('domain', {active:false}, true);
            }, CONFIG.DOMAIN_TIME);
        }
    }

    function updateDomainVisuals(d) {
        if(!d || !d.active) {
            if(domainGroup) { scene.remove(domainGroup); domainGroup=null; }
            document.getElementById('domainAudio').pause();
            isFrozen=false;
            return;
        }
        
        if(!domainGroup) {
            const aud = document.getElementById('domainAudio');
            aud.currentTime=0; aud.play().catch(()=>{});
            domainGroup = createCosmicDomain(d.pos);
            scene.add(domainGroup);
        }

        const me = getMe();
        if(me) {
            const mp = getPos(me);
            const dist = Math.hypot(mp.x-d.pos.x, mp.z-d.pos.z);
            if(dist <= CONFIG.DOMAIN_RADIUS && me.id !== d.owner) isFrozen=true;
        }
    }

    function triggerCooldownUI(id, time) {
        const el = document.getElementById(id);
        el.style.height = '100%';
        el.style.transition = `height ${time}ms linear`;
        el.offsetHeight; 
        el.style.height = '0%';
    }

    function updateHealthUI(hp) {
        const fill = document.getElementById('my-health-bar');
        const text = document.getElementById('hp-text');
        const pct = Math.max(0, (hp / CONFIG.MAX_HP) * 100);
        fill.style.width = `${pct}%`;
        text.innerText = `${Math.ceil(hp)}/${CONFIG.MAX_HP}`;
    }

    function getMe() {
        if(isOffline) return avatars["local_player"]?.state;
        return myPlayer();
    }

    function getPos(state) {
        if(isOffline) return state._data.pos;
        return state.getState('pos') || {x:0,y:0,z:0};
    }

    function respawn() {
        const me = getMe();
        me.setState('pos', {x:0,y:0,z:0}, true);
        const s = document.getElementById('dead-screen');
        s.style.display='flex';
        setTimeout(()=>s.style.display='none', 2000);
        updateHealthUI(CONFIG.MAX_HP);
    }

    // ==========================================
    // 6. SETUP GR√ÅFICO
    // ==========================================
    function setupScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const l = new THREE.DirectionalLight(0xffffff, 1);
      l.position.set(20,50,20); l.castShadow=true; scene.add(l);
      
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(300,300), new THREE.MeshStandardMaterial({color:0x228B22}));
      floor.rotation.x = -Math.PI/2; scene.add(floor);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function createMesh(color) {
      const g = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({color:0x1a1a1a});
      const skin = new THREE.MeshStandardMaterial({color:0xffccaa});

      const torso = new THREE.Mesh(new THREE.BoxGeometry(1,1.2,0.5), mat);
      torso.position.y=1.6; torso.name="Torso"; g.add(torso);
      
      const flash = new THREE.Mesh(new THREE.BoxGeometry(1.1,1.3,0.6), new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0}));
      flash.position.y=1.6; flash.name="HitFlash"; g.add(flash);

      const head = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), skin);
      head.position.y=2.5; g.add(head);

      const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.35,1.1,0.35), mat);
      rArm.position.set(0.75,1.6,0); rArm.name="RightArm"; g.add(rArm);
      const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.35,1.1,0.35), mat);
      lArm.position.set(-0.75,1.6,0); lArm.name="LeftArm"; g.add(lArm);

      const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.4,1.1,0.4), mat);
      rLeg.position.set(0.25,0.55,0); g.add(rLeg);
      const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.4,1.1,0.4), mat);
      lLeg.position.set(-0.25,0.55,0); g.add(lLeg);

      const bg = new THREE.Mesh(new THREE.PlaneGeometry(1.5,0.2), new THREE.MeshBasicMaterial({color:0x550000}));
      bg.position.set(0,3.5,0); bg.name="BarBG"; g.add(bg);
      const fg = new THREE.Mesh(new THREE.PlaneGeometry(1.5,0.2), new THREE.MeshBasicMaterial({color:0x00ff00}));
      fg.position.set(0,3.5,0.01); fg.name="BarFG"; g.add(fg);

      return g;
    }

    function triggerHitEffect(id) {
        const m = avatars[id]?.mesh;
        if(!m) return;
        const f = m.getObjectByName("HitFlash");
        if(f) { f.material.opacity = 0.8; setTimeout(()=>f.material.opacity=0, 100); }
        m.position.x += 0.2; setTimeout(()=>m.position.x -= 0.2, 50);
    }

    function doDash() {
        if(Date.now()-lastDash<CONFIG.DASH_CD || isFrozen) return;
        triggerCooldownUI('cd-dash', CONFIG.DASH_CD);
        lastDash=Date.now();
        
        const me = getMe();
        if(!me) return;
        
        const pos = getPos(me);
        const dir = new THREE.Vector3();
        
        if (isMouseLocked) {
             const fwd = new THREE.Vector3(Math.sin(cameraAngle), 0, Math.cos(cameraAngle));
             const right = new THREE.Vector3(Math.sin(cameraAngle - Math.PI/2), 0, Math.cos(cameraAngle - Math.PI/2));
             
             if (controls.fwd) dir.add(fwd);
             if (controls.back) dir.sub(fwd);
             if (controls.left) dir.sub(right);
             if (controls.right) dir.add(right);
             
             if (dir.lengthSq() === 0) dir.copy(fwd); // Dash forward default
        } else {
             if(controls.fwd) dir.z-=1; if(controls.back) dir.z+=1;
             if(controls.left) dir.x-=1; if(controls.right) dir.x+=1;
        }

        dir.normalize();
        
        const dest = {x: pos.x+dir.x*6, z: pos.z+dir.z*6};
        const final = checkBarrier(dest.x, dest.z);
        me.setState('pos', {x:final.x, y:0, z:final.z}, false);
    }

    function checkBarrier(x,z) {
        let d = isOffline ? activeDomain : getState('domain');
        if(!d || !d.active) return {x,z};
        
        const dx = x - d.pos.x;
        const dz = z - d.pos.z;
        const dist = Math.hypot(dx,dz);
        const R = CONFIG.DOMAIN_RADIUS;
        
        if(dist > R - 0.5) {
            const a = Math.atan2(dz,dx);
            return { x: d.pos.x+Math.cos(a)*(R-0.5), z: d.pos.z+Math.sin(a)*(R-0.5) };
        }
        return {x,z};
    }

    // ==========================================
    // 7. LOOP
    // ==========================================
    function animate() {
        requestAnimationFrame(animate);
        
        if(!isOffline) {
            checkIncomingDamage();
            updateDomainVisuals(getState('domain'));
        }

        const me = getMe();

        // Movimiento
        if(me && !isFrozen && !isRagdolled) {
            let pos = getPos(me);
            const speed = 0.2;
            const dir = new THREE.Vector3();

            if (isMouseLocked) {
                // Mover relativo a la c√°mara
                const fwd = new THREE.Vector3(Math.sin(cameraAngle), 0, Math.cos(cameraAngle));
                const right = new THREE.Vector3(Math.sin(cameraAngle - Math.PI/2), 0, Math.cos(cameraAngle - Math.PI/2));
                
                if (controls.fwd) dir.add(fwd);
                if (controls.back) dir.sub(fwd);
                if (controls.left) dir.sub(right);
                if (controls.right) dir.add(right);
            } else {
                if(controls.fwd) dir.z-=1; if(controls.back) dir.z+=1;
                if(controls.left) dir.x-=1; if(controls.right) dir.x+=1;
            }

            if(dir.lengthSq() > 0) {
                dir.normalize().multiplyScalar(speed);
                const dest = {x: pos.x+dir.x, z: pos.z+dir.z};
                const fin = checkBarrier(dest.x, dest.z);
                me.setState('pos', {x:fin.x, y:0, z:fin.z}, false);
            }
        }

        // Render Avatares
        const time = Date.now() * 0.001;
        for(const id in avatars) {
            const {mesh, state} = avatars[id];
            let p = getPos(state);
            
            mesh.position.lerp(new THREE.Vector3(p.x, mesh.position.y, p.z), 0.3);

            if (id === (me ? me.id : '') && isMouseLocked) {
                mesh.rotation.y = cameraAngle + Math.PI; 
            } else {
                const lp = mesh.userData.lp || p;
                const dx = p.x - lp.x; const dz = p.z - lp.z;
                if(Math.hypot(dx,dz) > 0.01) mesh.rotation.y = Math.atan2(dx,dz);
                mesh.userData.lp = p;
            }

            const isMoving = (mesh.position.distanceTo(new THREE.Vector3(p.x,0,p.z)) > 0.01);
            animateWalk(id, isMoving, time);

            let isRag = isOffline ? state._data.ragdoll : state.getState('ragdoll');
            if(isRag) {
                mesh.rotation.x = -Math.PI/2; mesh.position.y = 0.5;
            } else if (!isMoving) {
                mesh.rotation.x = 0;
            }

            const bg = mesh.getObjectByName("BarBG");
            if(bg) bg.parent.visible = (id !== (me ? me.id : ''));
            if(bg && bg.parent.visible) {
                 let hp = isOffline ? state._data.hp : state.getState('hp');
                 if(hp===undefined) hp=100;
                 const fg = mesh.getObjectByName("BarFG");
                 fg.scale.x = Math.max(0, hp/100);
                 bg.parent.lookAt(camera.position);
            }
        }

        // FIX C√ÅMARA (Estaba al rev√©s)
        if(me) {
            const p = getPos(me);
            // Distancia 14, DETR√ÅS del jugador
            const dist = 14;
            // Para estar detr√°s, restamos seno/coseno del angulo
            const camX = p.x - Math.sin(cameraAngle) * dist;
            const camZ = p.z - Math.cos(cameraAngle) * dist;
            
            // Altura de c√°mara ajustada para ver desde arriba/atr√°s
            const camY = p.y + 4 + (cameraVertical * 10);

            camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.2);
            camera.lookAt(p.x, p.y + 3, p.z);
        }

        if(domainGroup) domainGroup.rotation.y += 0.002;
        renderer.render(scene, camera);
    }

    init().catch(console.error);
  </script>
</body>
</html>
